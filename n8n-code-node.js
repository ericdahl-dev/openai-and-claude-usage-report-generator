// n8n Code Node for OpenAI Usage Report Generation
// This code replicates the functionality of src/usage-report.ts
//
// USAGE IN N8N:
// 1. Add a Code node to your workflow
// 2. Set Mode to "Run Once for All Items" (recommended) or "Run Once for Each Item"
// 3. Paste this entire code into the Code node
// 4. Connect it after a node that provides OpenAI API cost data (HTTP Request node calling OpenAI API)
// 5. The input should be the JSON response from OpenAI's /organization/costs endpoint
// 6. The output will be a JSON report matching the format generated by src/usage-report.ts
//
// INPUT FORMAT:
// The code expects input data in one of these formats:
// - Array of page objects: [{object: "page", data: [buckets...]}]
// - Single page object: {object: "page", data: [buckets...]}
// - Direct array of buckets: [{object: "bucket", start_time: ..., results: [...]}]
//
// OUTPUT FORMAT:
// Returns a single item with json property containing the report object with:
// - metadata (provider, generated timestamp, billing period, project/organization IDs)
// - summary (total cost, billing days, average daily cost)
// - costsByLineItem (array of costs grouped by model/service)
// - dailyBreakdown (array of daily costs)
// - dailyTotals (array of daily totals)

// Helper function to normalize costs (round up < 0.01, filter out <= 0)
function normalizeCost(cost) {
  if (cost <= 0) {
    return null;
  }
  if (cost < 0.01) {
    return 0.01;
  }
  return cost;
}

// Extract buckets from the input data structure
function extractBuckets(inputData) {
  // Input can be either:
  // 1. An array with page objects: [{object: "page", data: [...]}]
  // 2. A single page object: {object: "page", data: [...]}
  // 3. Already an array of buckets: [...]
  
  let buckets = [];
  
  if (Array.isArray(inputData)) {
    // Check if first item is a page object
    if (inputData.length > 0 && inputData[0].object === 'page') {
      // Extract buckets from all page objects
      for (const page of inputData) {
        if (page.data && Array.isArray(page.data)) {
          buckets.push(...page.data);
        }
      }
    } else {
      // Already an array of buckets
      buckets = inputData;
    }
  } else if (inputData && inputData.object === 'page' && Array.isArray(inputData.data)) {
    buckets = inputData.data;
  } else {
    throw new Error('Invalid input format. Expected page object or array of buckets.');
  }
  
  return buckets;
}

// Extract metadata from buckets
function extractMetadata(buckets) {
  if (buckets.length === 0) {
    throw new Error('No buckets found in input data');
  }
  
  // Find first bucket with results to get project_id and organization_id
  let projectId = null;
  let organizationId = null;
  
  for (const bucket of buckets) {
    if (bucket.results && bucket.results.length > 0) {
      const firstResult = bucket.results[0];
      projectId = firstResult.project_id || null;
      organizationId = firstResult.organization_id || null;
      break;
    }
  }
  
  // Extract start and end dates from bucket timestamps
  const sortedBuckets = [...buckets].sort((a, b) => a.start_time - b.start_time);
  const firstBucket = sortedBuckets[0];
  const lastBucket = sortedBuckets[sortedBuckets.length - 1];
  
  const startDate = new Date(firstBucket.start_time * 1000).toISOString().split('T')[0];
  const endDate = new Date(lastBucket.end_time * 1000).toISOString().split('T')[0];
  
  return {
    startDate,
    endDate,
    projectId: projectId || 'unknown',
    organizationId: organizationId || 'unknown',
  };
}

// Aggregate costs from buckets (same logic as aggregateCosts in usage-report.ts)
function aggregateCosts(buckets, startDate, endDate, projectId) {
  const dailyCosts = [];
  const costsByLineItem = new Map();
  let totalCost = 0;
  
  for (const bucket of buckets) {
    const date = new Date(bucket.start_time * 1000).toISOString().split('T')[0];
    
    if (bucket.results && Array.isArray(bucket.results)) {
      for (const result of bucket.results) {
        // Ensure cost is a number (API might return string)
        const cost = typeof result.amount.value === 'string'
          ? parseFloat(result.amount.value)
          : result.amount.value;
        const lineItem = result.line_item || 'unknown';
        
        totalCost += cost;
        
        // Aggregate by line item
        const currentLineItemCost = costsByLineItem.get(lineItem) || 0;
        costsByLineItem.set(lineItem, currentLineItemCost + cost);
        
        // Daily breakdown
        dailyCosts.push({
          date,
          lineItem,
          cost,
        });
      }
    }
  }
  
  const billingDays = buckets.length;
  const averageDailyCost = billingDays > 0 ? totalCost / billingDays : 0;
  
  return {
    totalCost,
    startDate,
    endDate,
    projectId,
    dailyCosts,
    costsByLineItem,
    billingDays,
    averageDailyCost,
  };
}

// Generate JSON report (same logic as generateJSONReport in usage-report.ts)
function generateJSONReport(aggregated, orgId, provider = 'openai') {
  // Convert Map to array of objects for JSON serialization
  const costsByLineItem = Array.from(aggregated.costsByLineItem.entries())
    .map(([lineItem, cost]) => {
      const normalizedCost = normalizeCost(cost);
      return normalizedCost !== null ? { lineItem, cost: normalizedCost } : null;
    })
    .filter(item => item !== null)
    .map(({ lineItem, cost }) => ({
      lineItem,
      cost,
      percentage: aggregated.totalCost > 0 ? (cost / aggregated.totalCost * 100) : 0,
    }))
    .sort((a, b) => b.cost - a.cost);
  
  // Calculate daily totals
  const dailyTotals = new Map();
  for (const daily of aggregated.dailyCosts) {
    const normalizedCost = normalizeCost(daily.cost);
    if (normalizedCost !== null) {
      const current = dailyTotals.get(daily.date) || 0;
      dailyTotals.set(daily.date, current + normalizedCost);
    }
  }
  
  const dailyTotalsArray = Array.from(dailyTotals.entries())
    .map(([date, total]) => ({ date, total }))
    .sort((a, b) => a.date.localeCompare(b.date));
  
  const json = {
    metadata: {
      provider,
      generated: new Date().toISOString(),
      billingPeriod: {
        startDate: aggregated.startDate,
        endDate: aggregated.endDate,
      },
      projectId: aggregated.projectId,
      organizationId: orgId,
    },
    summary: {
      billingPeriod: {
        startDate: aggregated.startDate,
        endDate: aggregated.endDate,
      },
      totalCost: aggregated.totalCost,
      billingDays: aggregated.billingDays,
      averageDailyCost: aggregated.averageDailyCost,
    },
    costsByLineItem,
    dailyBreakdown: aggregated.dailyCosts
      .map(d => {
        const normalizedCost = normalizeCost(d.cost);
        return normalizedCost !== null ? { date: d.date, lineItem: d.lineItem, cost: normalizedCost } : null;
      })
      .filter(d => d !== null)
      .sort((a, b) => {
        const dateCompare = a.date.localeCompare(b.date);
        if (dateCompare !== 0) return dateCompare;
        return a.lineItem.localeCompare(b.lineItem);
      }),
    dailyTotals: dailyTotalsArray,
  };
  
  return json;
}

// Main execution
try {
  // Get input data from n8n
  // $input.all() returns all input items, $input.first() returns first item
  const inputItems = $input.all();
  
  if (inputItems.length === 0) {
    throw new Error('No input data received');
  }
  
  // Extract JSON data from input items
  // Handle different input formats:
  // 1. Single item with json property containing the API response
  // 2. Multiple items, each with json property
  // 3. Direct JSON data
  let inputData;
  
  if (inputItems.length === 1) {
    const item = inputItems[0];
    // Check if it's already the data structure we need
    if (item.json && (item.json.object === 'page' || Array.isArray(item.json))) {
      inputData = item.json;
    } else if (Array.isArray(item.json) && item.json.length > 0 && item.json[0].object === 'page') {
      inputData = item.json;
    } else {
      // Try the whole item
      inputData = item.json || item;
    }
  } else {
    // Multiple items - extract json from each
    inputData = inputItems.map(item => item.json || item);
  }
  
  // Extract buckets from input data
  const buckets = extractBuckets(inputData);
  
  if (buckets.length === 0) {
    throw new Error('No cost buckets found in input data');
  }
  
  // Extract metadata
  const metadata = extractMetadata(buckets);
  
  // Aggregate costs
  const aggregated = aggregateCosts(
    buckets,
    metadata.startDate,
    metadata.endDate,
    metadata.projectId
  );
  
  // Generate JSON report
  const report = generateJSONReport(aggregated, metadata.organizationId, 'openai');
  
  // Return result in n8n format
  return [{
    json: report
  }];
  
} catch (error) {
  // Return error in n8n format
  throw new Error(`Failed to generate report: ${error.message}`);
}
